//includes
#include <math.h>
#include <math/point.hpp>

//RMC - change class name!
void sample_array::calc_weights(OccupancyGrid grid, laser_scan_t lasers)
{
    double max_weight = 0.0;

    for (int n = 0; n < this.num_samples; n++)
    {
        maebot_pose_t pose = this.poses[n];
        int num_rays = lasers.num_ranges();
        
        double calc_weight = 0.0;            

        for (int r = 0; r < num_rays; r++)
        {
            if (lasers[r].get_intensity() == 0) {continue;}

            float theta = lasers[r].get_theta();
            float range = lasers[r].get_range();
            float mae_x = pose.get_x_pos();
            float mae_y = pose.get_y_pos();
            
            float cos = cosf(theta);
            float sin = sinf(theta);

            for (float sample_m = 0.0; sample_m < range; sample_m += 0.05) //sample along laser path
            {
                float dx = sample_m * cos;
                float dy = sample_m * sin;
                
                eecs467::Point<int> sample_cell = global_position_to_grid_cell(eecs467::Point<float>(mae_x + dx, mae_y + dy), grid);
                
                if (grid.isCellInGrid(sample_cell.y, sample_cell.x))
                {
                    if (grid.logOdds(sample_cell.y, sample_cell.x) > 0) //laser longer than expected
                    {
                        calc_weight -= 12;
                        break;
                    }
                } 
            }
            
            //sample_cell = laser termination cell
            sample_cell = global_position_to_grid_cell(eecs467::Point<float>(mae_x + (range*cos), mae_y + (range*sin)), grid);
            
            if (grid.isCellInGrid(sample_cell.y, sample_cell.x))
            {
                if (grid.logOdds(sample_cell.y, sample_cell.x) > 0) //laser is expected dist
                {
                    calc_weight -= 4;
                }
                else //laser shorter than expected
                {
                    calc_weight -= 8;
                }
            }
     
        }
        
        if (calc_weight < max_weight)
        {
            max_weight = calc_weight;
        }
        
        this.weights[n] = calc_weight;
    }
    
    //normalize
    for (int s = 0; s < this.num_samples; s++)
    {
        this.weights[s] += max;
        //exponentiate...
    }
}

